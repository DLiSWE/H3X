// This file is @generated by prost-build.
/// Sent by client to authenticate itself.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Auth {
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Represents a single application event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// UUID as string
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// "Error", "Metric", etc.
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    /// arbitrary serialized payload
    #[prost(bytes = "vec", tag = "5")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Unix seconds
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    #[prost(map = "string, string", tag = "7")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Request from client to fetch queued events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchEvents {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// optional limit
    #[prost(uint32, tag = "2")]
    pub max_events: u32,
}
/// Acknowledges receipt of a specific event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AckEvent {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// UUID as string
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
}
/// Batch of events sent from server to client.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventsBatch {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
/// Ping Pong
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ping {
    /// client send time
    #[prost(uint64, tag = "1")]
    pub timestamp_ms: u64,
    /// optional sequence/nonce
    #[prost(uint64, tag = "2")]
    pub seq: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Pong {
    /// echoed from Ping.timestamp_ms
    #[prost(uint64, tag = "1")]
    pub echo_timestamp_ms: u64,
    /// optional server clock
    #[prost(uint64, tag = "2")]
    pub server_time_ms: u64,
    /// echoed seq
    #[prost(uint64, tag = "3")]
    pub seq: u64,
}
/// The main transport frame.
/// All data is sent as a length-delimited Frame over the stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Frame {
    /// Protocol version
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Logical stream ID
    #[prost(uint32, tag = "2")]
    pub stream_id: u32,
    /// Kind of payload
    #[prost(enumeration = "FrameType", tag = "3")]
    pub r#type: i32,
    /// Exactly one payload should be set per frame.
    #[prost(oneof = "frame::Payload", tags = "10, 11, 12, 13, 14, 15, 16")]
    pub payload: ::core::option::Option<frame::Payload>,
}
/// Nested message and enum types in `Frame`.
pub mod frame {
    /// Exactly one payload should be set per frame.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Auth(super::Auth),
        #[prost(message, tag = "11")]
        Event(super::Event),
        #[prost(message, tag = "12")]
        FetchEvents(super::FetchEvents),
        #[prost(message, tag = "13")]
        EventsBatch(super::EventsBatch),
        #[prost(message, tag = "14")]
        AckEvent(super::AckEvent),
        /// NEW
        #[prost(message, tag = "15")]
        Ping(super::Ping),
        /// NEW
        #[prost(message, tag = "16")]
        Pong(super::Pong),
    }
}
/// Enum representing all supported frame types.
/// These values match your old FrameType u8 mapping exactly.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameType {
    /// default (unused in practice)
    Unspecified = 0,
    Ping = 1,
    Pong = 2,
    Auth = 3,
    Event = 4,
    FetchEvents = 5,
    EventsBatch = 6,
    AckEvent = 7,
    Ack = 8,
    Nack = 9,
    AuthAck = 10,
    AuthError = 11,
}
impl FrameType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FRAME_TYPE_UNSPECIFIED",
            Self::Ping => "FRAME_TYPE_PING",
            Self::Pong => "FRAME_TYPE_PONG",
            Self::Auth => "FRAME_TYPE_AUTH",
            Self::Event => "FRAME_TYPE_EVENT",
            Self::FetchEvents => "FRAME_TYPE_FETCH_EVENTS",
            Self::EventsBatch => "FRAME_TYPE_EVENTS_BATCH",
            Self::AckEvent => "FRAME_TYPE_ACK_EVENT",
            Self::Ack => "FRAME_TYPE_ACK",
            Self::Nack => "FRAME_TYPE_NACK",
            Self::AuthAck => "FRAME_TYPE_AUTH_ACK",
            Self::AuthError => "FRAME_TYPE_AUTH_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FRAME_TYPE_PING" => Some(Self::Ping),
            "FRAME_TYPE_PONG" => Some(Self::Pong),
            "FRAME_TYPE_AUTH" => Some(Self::Auth),
            "FRAME_TYPE_EVENT" => Some(Self::Event),
            "FRAME_TYPE_FETCH_EVENTS" => Some(Self::FetchEvents),
            "FRAME_TYPE_EVENTS_BATCH" => Some(Self::EventsBatch),
            "FRAME_TYPE_ACK_EVENT" => Some(Self::AckEvent),
            "FRAME_TYPE_ACK" => Some(Self::Ack),
            "FRAME_TYPE_NACK" => Some(Self::Nack),
            "FRAME_TYPE_AUTH_ACK" => Some(Self::AuthAck),
            "FRAME_TYPE_AUTH_ERROR" => Some(Self::AuthError),
            _ => None,
        }
    }
}
