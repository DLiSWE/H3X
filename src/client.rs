// This file implements a QUIC client using the `quinn` library.
// It connects to a QUIC server, sends a message, and handles the connection asynchronously.
// This client is intended for local development and testing purposes.
// It uses a self-signed TLS certificate generated by the `generate_or_load_cert` function from the `tls` module.
// The client connects to the server at a specified address and port.
// The `run_client` function establishes the connection and sends a message.
// The client is designed to work with the QUIC server implemented in `server.rs`.
// It uses the `tokio` runtime for asynchronous operations and the `quinn` crate for QUIC functionality.
// The client can be run in a Tokio runtime environment to test the QUIC server.

use quinn::{ClientConfig, Endpoint};
use rustls::{ClientConfig as RustlsClientConfig, RootCertStore};
use std::sync::Arc;
use std::time::Duration;
use tokio::time::sleep;

use crate::tls::generate_or_load_cert;
use crate::protocol::frame::H3XFrame;
use crate::protocol::types::FrameType;

pub async fn run_client() {
    let (cert_chain, _) = generate_or_load_cert();
    let cert = &cert_chain[0];

    // Create a RootCertStore and add the server certificate
    // This is necessary for the client to trust the server's certificate.
    let mut roots = RootCertStore::empty();
    roots.add(cert).unwrap();

    // Create a Rustls client configuration with the root certificates
    // This configuration will be used by the QUIC client endpoint.
    let client_crypto = {
        let config = RustlsClientConfig::builder()
            .with_safe_defaults()
            .with_root_certificates(roots)
            .with_no_client_auth();

        Arc::new(config)
    };

    let client_config = ClientConfig::new(client_crypto);
    let mut endpoint = match Endpoint::client("0.0.0.0:0".parse().unwrap()) {
        Ok(ep) => ep,
        Err(e) => {
            eprintln!("âŒ Failed to create client endpoint: {e}");
            return;
        }
    };

    endpoint.set_default_client_config(client_config);

    let connecting = match endpoint.connect("127.0.0.1:5000".parse().unwrap(), "localhost") {
        Ok(conn) => conn,
        Err(e) => {
            eprintln!("âŒ Failed to initiate connection: {e}");
            return;
        }
    };

    let conn = match connecting.await {
        Ok(c) => c,
        Err(e) => {
            eprintln!("âŒ Connection failed: {e}");
            return;
        }
    };

    println!("ðŸ¤ Connected to server");

    let mut retry_delay = Duration::from_secs(1);

    loop {
        match conn.open_bi().await {
            Ok((mut send, mut recv)) => {
                retry_delay = Duration::from_secs(1); // reset on success

                let frame = H3XFrame {
                    stream_id: 99,
                    frame_type: FrameType::Ping,
                    payload: vec![],
                };

                if let Err(e) = frame.write_to(&mut send).await {
                    eprintln!("âŒ Failed to send frame: {e}");
                    continue;
                }

                if let Err(e) = send.finish().await {
                    eprintln!("âŒ Failed to finish stream: {e}");
                    continue;
                }

                match H3XFrame::read_from(&mut recv).await {
                    Ok(Some(reply)) => println!("ðŸ“¬ Server replied: {:?}", reply),
                    Ok(None) => println!("ðŸ“´ Server closed stream"),
                    Err(e) => eprintln!("âŒ Failed to read response: {e}"),
                }
            }

            Err(e) => {
                eprintln!("âŒ Failed to open stream: {e}. Retrying in {}s...", retry_delay.as_secs());
                sleep(retry_delay).await;
                retry_delay *= 2;
                if retry_delay > Duration::from_secs(30) {
                    retry_delay = Duration::from_secs(30);
                }
            }
        }

        sleep(Duration::from_secs(5)).await;
    }

}
