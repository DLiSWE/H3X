mod ping;

// This file implements a QUIC client using the `quinn` library.
// It connects to a QUIC server, sends a message, and handles the connection asynchronously.
// This client is intended for local development and testing purposes.
// It uses a self-signed TLS certificate generated by the `generate_or_load_cert` function from the `tls` module.
// The client connects to the server at a specified address and port.
// The `run_client` function establishes the connection and sends a message.
// The client is designed to work with the QUIC server implemented in `server.rs`.
// It uses the `tokio` runtime for asynchronous operations and the `quinn` crate for QUIC functionality.
// The client can be run in a Tokio runtime environment to test the QUIC server.

use quinn::{ClientConfig, Endpoint};
use rustls::{ClientConfig as RustlsClientConfig, RootCertStore};
use std::sync::Arc;

use ping::start_ping_loop;
use crate::tls::generate_or_load_cert;

pub async fn run_client() {
    let (cert_chain, _) = generate_or_load_cert();
    let cert = &cert_chain[0];

    // Create a RootCertStore and add the server certificate
    // This is necessary for the client to trust the server's certificate.
    let mut roots = RootCertStore::empty();
    roots.add(cert).unwrap();

    // Create a Rustls client configuration with the root certificates
    // This configuration will be used by the QUIC client endpoint.
    let client_crypto = {
        let config = RustlsClientConfig::builder()
            .with_safe_defaults()
            .with_root_certificates(roots)
            .with_no_client_auth();

        Arc::new(config)
    };

    let client_config = ClientConfig::new(client_crypto);
    let mut endpoint = match Endpoint::client("0.0.0.0:0".parse().unwrap()) {
        Ok(ep) => ep,
        Err(e) => {
            eprintln!("❌ Failed to create client endpoint: {e}");
            return;
        }
    };

    endpoint.set_default_client_config(client_config);

    let connecting = match endpoint.connect("127.0.0.1:5000".parse().unwrap(), "localhost") {
        Ok(conn) => conn,
        Err(e) => {
            eprintln!("❌ Failed to initiate connection: {e}");
            return;
        }
    };

    let conn = match connecting.await {
        Ok(c) => c,
        Err(e) => {
            eprintln!("❌ Connection failed: {e}");
            return;
        }
    };

    println!("🤝 Connected to server");

    start_ping_loop(conn).await;
}
